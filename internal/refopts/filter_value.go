package refopts

import (
	"fmt"
	"strconv"

	"github.com/github/git-sizer/git"
)

type filterValue struct {
	// filter is the filter that will be modified if this option
	// is used.
	filter *git.ReferenceFilter

	// combiner specifies how the filter generated by this option
	// is combined with the existing filter; i.e., does it cause
	// the matching references to be included or excluded?
	combiner git.Combiner

	// pattern, if it is set, is the pattern (prefix or regexp) to
	// be matched. If it is not set, then the user must supply the
	// pattern.
	pattern string

	// regexp specifies whether `pattern` should be interpreted as
	// a regexp (as opposed to a prefix).
	regexp bool
}

func (v *filterValue) Set(s string) error {
	var filter git.ReferenceFilter
	combiner := v.combiner

	var pattern string
	if v.pattern != "" {
		// The pattern is fixed for this option:
		pattern = v.pattern

		// It's not really expected, but if the user supplied a
		// `false` boolean value, invert the polarity:
		b, err := strconv.ParseBool(s)
		if err != nil {
			return err
		}
		if !b {
			combiner = combiner.Inverted()
		}
	} else {
		// The user must supply the pattern.
		pattern = s
	}

	if v.regexp {
		var err error
		filter, err = git.RegexpFilter(pattern)
		if err != nil {
			return fmt.Errorf("invalid regexp: %q", s)
		}
	} else {
		filter = git.PrefixFilter(pattern)
	}

	*v.filter = combiner.Combine(*v.filter, filter)

	return nil
}

func (v *filterValue) Get() interface{} {
	return nil
}

func (v *filterValue) String() string {
	return ""
}

func (v *filterValue) Type() string {
	if v.pattern != "" {
		return "bool"
	} else if v.regexp {
		return "regexp"
	} else {
		return "prefix"
	}
}
